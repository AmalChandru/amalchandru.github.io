<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How Containers Actually Work: Building Container Networking From Scratch | Amal Chandran M V</title>
<meta name="keywords" content="linux, container, networking">
<meta name="description" content="Containers often feel like magic, and container networking can seem like a higher form of black magic. A process starts, gets its own IP address, can reach the internet, and talks to other containers. All without us touching low-level networking.
But nothing magical is happening.
Under the hood, container networking is built from a small set of Linux primitives: network namespaces, virtual Ethernet devices (veth), routing tables and NAT. In this write-up, we&rsquo;ll build that setup manually to see exactly what Docker and other container runtimes are doing on our behalf.">
<meta name="author" content="">
<link rel="canonical" href="https://amalchandran.xyz/journals/building-container-networking-from-scratch-part-1/">
<link crossorigin="anonymous" href="https://amalchandran.xyz/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://amalchandran.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://amalchandran.xyz/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://amalchandran.xyz/assets/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://amalchandran.xyz/assets/apple-touch-icon.png">
<link rel="mask-icon" href="https://amalchandran.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://amalchandran.xyz/journals/building-container-networking-from-scratch-part-1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YV335L7966"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YV335L7966');
</script><meta property="og:url" content="https://amalchandran.xyz/journals/building-container-networking-from-scratch-part-1/">
  <meta property="og:site_name" content="Amal Chandran M V">
  <meta property="og:title" content="How Containers Actually Work: Building Container Networking From Scratch">
  <meta property="og:description" content="Containers often feel like magic, and container networking can seem like a higher form of black magic. A process starts, gets its own IP address, can reach the internet, and talks to other containers. All without us touching low-level networking.
But nothing magical is happening.
Under the hood, container networking is built from a small set of Linux primitives: network namespaces, virtual Ethernet devices (veth), routing tables and NAT. In this write-up, we’ll build that setup manually to see exactly what Docker and other container runtimes are doing on our behalf.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="journals">
    <meta property="article:published_time" content="2026-02-04T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-02-04T00:00:00+00:00">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Container">
    <meta property="article:tag" content="Networking">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="How Containers Actually Work: Building Container Networking From Scratch">
<meta name="twitter:description" content="Containers often feel like magic, and container networking can seem like a higher form of black magic. A process starts, gets its own IP address, can reach the internet, and talks to other containers. All without us touching low-level networking.
But nothing magical is happening.
Under the hood, container networking is built from a small set of Linux primitives: network namespaces, virtual Ethernet devices (veth), routing tables and NAT. In this write-up, we&rsquo;ll build that setup manually to see exactly what Docker and other container runtimes are doing on our behalf.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Journals",
      "item": "https://amalchandran.xyz/journals/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How Containers Actually Work: Building Container Networking From Scratch",
      "item": "https://amalchandran.xyz/journals/building-container-networking-from-scratch-part-1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How Containers Actually Work: Building Container Networking From Scratch",
  "name": "How Containers Actually Work: Building Container Networking From Scratch",
  "description": "Containers often feel like magic, and container networking can seem like a higher form of black magic. A process starts, gets its own IP address, can reach the internet, and talks to other containers. All without us touching low-level networking.\nBut nothing magical is happening.\nUnder the hood, container networking is built from a small set of Linux primitives: network namespaces, virtual Ethernet devices (veth), routing tables and NAT. In this write-up, we\u0026rsquo;ll build that setup manually to see exactly what Docker and other container runtimes are doing on our behalf.",
  "keywords": [
    "linux", "container", "networking"
  ],
  "articleBody": "Containers often feel like magic, and container networking can seem like a higher form of black magic. A process starts, gets its own IP address, can reach the internet, and talks to other containers. All without us touching low-level networking.\nBut nothing magical is happening.\nUnder the hood, container networking is built from a small set of Linux primitives: network namespaces, virtual Ethernet devices (veth), routing tables and NAT. In this write-up, we’ll build that setup manually to see exactly what Docker and other container runtimes are doing on our behalf.\nThe Four Linux Primitives Behind Container Networking Docker and container runtimes, in general, did not invent container networking. They assemble a few Linux kernel features that have existed for years.\nContainer networking is built on four core primitives:\nNetwork namespaces Virtual Ethernet (veth) devices Routing tables NAT (iptables) Network Namespaces: The Separate Network Worlds A network namespace is a fully independent instance of the Linux networking stack. When a process runs inside the namespace, it gets its own:\nNetwork interfaces Routing table ARP table Firewall rules (iptables) Loopback device It cannot see the host’s networking interfaces, and the host cannot see its internal ones either (unless explicitly connected). From a networking perspective, it’s as if that process is running on a completely different machine.\nContainer network isolation is simply a process placed inside its own network namespace.\nThat’s the foundation of container networking.\nVirtual Ethernet (veth) Pairs: The Wire that connects the Worlds Now we have two separate network worlds: the host and the namespace. They need a wire between them. That wire is a veth pair.\nA veth pair is created as two connected virtual interfaces:\nveth-A \u003c==== virtual cable ====\u003e veth-B Anything that enters one end comes out the other.\nTypically:\nOne end stays in the host The other end is moved into the container’s namespace This is how packets physically move between the container and the host network stack.\nA veth pair is just an Ethernet cable, except both ends live inside the kernel.\nRouting: How Packets Know Where to Go Interfaces move packets, but routing tables decide where packets should be sent. Each namespace maintains its own routing table.\nWhen a process sends traffic:\nKernel checks the destination IP Looks up the routing table Chooses the correct interface Without a default route, a namespace can only talk to its own subnet. So if a container wants internet access, it needs a rule like:\n“Anything not local -\u003e send to the host”\nThis rule makes the host act as a gateway.\nNAT: How Containers Reach the Internet Containers usually use private IP addresses (like 10.x.x.x or 172.x.x.x). The internet doesn’t know how to route traffic back to those.\nSo the host performs Network Address Translation (NAT)\nWhen packets leave the host:\nThe container’s source IP is replaced with the host’s IP Return traffic comes back to the host The kernel maps it back to the original container This is done using an iptables MASQUERADE rule\nContainers don’t have public IPs. They borrow the host’s identity when talking to the outside world.\nPutting It Together At this point, container networking is no longer mysterious:\nProblem Linux Primitive That Solves It Isolation Network namespace Connection to host veth pair Traffic direction Routing table Internet access NAT (iptables) Docker is simply automating the creation and wiring of these pieces.\nIn the upcoming sections, we’ll build this entire setup manually (the same way a container runtime does).\nBuilding Container Networking From Scratch Now we’ll manually build the same network setup a container runtime creates automatically.\nWe will:\nCreate a network namespace Connect it to the host using a veth pair Assign IP addresses Add routing Enable IP forwarding Add NAT Test connectivity 1. Create a Network Namespace This namespace will act as our “container”.\nsudo ip netns add myns We can run commands inside it using:\nsudo ip netns exec myns bash At this point, the namespace exists. But it has no network connectivity except a downed loopback interface. Try listing the available links inside the namespace.\nsudo ip netns exec myns ip link list You’ll see the loopback interface.\n2. Create a veth Pair (Virtual Cable) We’ll now create a virtual Ethernet cable between the host and the namespace.\nsudo ip link add veth-host type veth peer name veth-ns This creates:\nveth-host \u003c====\u003e veth-ns Move one end into the namespace:\nsudo ip link set veth-ns netns myns Now:\nSide Interface Host veth-host Namespace veth-ns 3. Assign IP Addresses The two ends must be on the same subnet.\nHost side:\nsudo ip addr add 10.10.0.1/24 dev veth-host sudo ip link set veth-host up Namespace side:\nsudo ip netns exec myns ip addr add 10.10.0.2/24 dev veth-ns sudo ip netns exec myns ip link set veth-ns up sudo ip netns exec myns ip link set lo up Now the host and namespace can talk at Layer 3.\nWhy bring up lo? Because every network stack expects a working loopback interface. This ensures localhost works correctly inside the namespace.\n4. Add a Default Route Inside the Namespace Right now the namespace only knows its local subnet. We make the host act as a gateway:\nsudo ip netns exec myns ip route add default via 10.10.0.1 Now any traffic destined outside 10.10.0.0/24 goes to the host. The namespace now has a default gateway.\n5. Enable IP Forwarding on the Host Linux drops forwarded packets by default.\nsudo sysctl -w net.ipv4.ip_forward=1 The host can now behave like a router. This change is temporary and will reset after reboot.\n6. Add NAT (Masquerading) The namespace IP is private. We must rewrite packets leaving the host.\nReplace wlo1 with your internet-facing interface.\nsudo iptables -t nat -A POSTROUTING -s 10.10.0.0/24 -o wlo1 -j MASQUERADE This makes outbound traffic appear as if it originates from the host. This is the same mechanism home routers use to allow multiple devices to share one public IP.\n7. Allow Forwarded Traffic sudo iptables -A FORWARD -i veth-host -o wlo1 -j ACCEPT sudo iptables -A FORWARD -o veth-host -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT These rules allow traffic to leave and return. The first rule allows outbound traffic from the namespace to the external interface. The second rule allows return traffic for established connections, so responses from the internet can flow back into the namespace.\n8. Test Connectivity Namespace → Host\nsudo ip netns exec myns ping 10.10.0.1 Namespace → Internet\nsudo ip netns exec myns ping 8.8.8.8 If this works, you have built container-style networking manually.\nWhat We Just Built myns process ↓ veth-ns ↓ veth-host ↓ Host routing table ↓ iptables NAT (MASQUERADE) ↓ wlo1 ↓ Router → Internet At this point, the namespace can reach the host and the internet. That means we have successfully built container-style networking using nothing but Linux kernel primitives.\nLet’s look at what actually happened.\nWe created a separate network world using a network namespace. We connected that world to the host using a veth pair. We told the namespace where to send unknown traffic using a default route. We allowed the host to forward packets by enabling IP forwarding. We let the namespace talk to the internet by adding NAT (MASQUERADE) rules. That is the core of container networking.\nWhen you run: docker run nginx\nDocker performs these same steps automatically. It creates a namespace for the container, wires it to the host network, adds routing rules, and inserts iptables rules so traffic can flow in and out. What feels like a high-level abstraction is just automation around standard Linux networking features.\nWhat we built is the simplest container networking model: one isolated network stack using the host as its gateway.\nA container does not get special networking.\nIt is simply a process inside a separate network namespace, connected to the host using a virtual Ethernet cable.\nThe host acts as a router and performs NAT so the container can reach the internet.\nEverything else in container networking builds on this exact pattern.\nReal container platforms add another layer on top of this.\nInstead of connecting each namespace directly to the host, they attach multiple namespaces to a Linux bridge, allowing containers to talk to each other as if they were on the same switch. That bridge is what Docker exposes as docker0.\nWe’ll build that in the next part.\n",
  "wordCount" : "1388",
  "inLanguage": "en",
  "datePublished": "2026-02-04T00:00:00Z",
  "dateModified": "2026-02-04T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://amalchandran.xyz/journals/building-container-networking-from-scratch-part-1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Amal Chandran M V",
    "logo": {
      "@type": "ImageObject",
      "url": "https://amalchandran.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://amalchandran.xyz/" accesskey="h" title="Amal Chandran M V (Alt + H)">Amal Chandran M V</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://amalchandran.xyz/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://amalchandran.xyz/journals/" title="Journals">
                    <span>Journals</span>
                </a>
            </li>
            <li>
                <a href="https://amalchandran.xyz/talks" title="Talks">
                    <span>Talks</span>
                </a>
            </li>
            <li>
                <a href="https://amalchandran.xyz/self" title="Self">
                    <span>Self</span>
                </a>
            </li>
            <li>
                <a href="https://amalchandran.xyz/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      How Containers Actually Work: Building Container Networking From Scratch
    </h1>
    <div class="post-meta"><span title='2026-02-04 00:00:00 +0000 UTC'>February 4, 2026</span>

</div>
  </header> 
  <div class="post-content"><p>Containers often feel like magic, and container networking can seem like a higher form of black magic. A process starts, gets its own IP address, can reach the internet, and talks to other containers. All without us touching low-level networking.</p>
<p>But nothing magical is happening.</p>
<p>Under the hood, container networking is built from a small set of Linux primitives: <strong>network namespaces</strong>, <strong>virtual Ethernet devices (veth)</strong>, <strong>routing tables</strong> and <strong>NAT</strong>. In this write-up, we&rsquo;ll build that setup manually to see exactly what Docker and other container runtimes are doing on our behalf.</p>
<h2 id="the-four-linux-primitives-behind-container-networking">The Four Linux Primitives Behind Container Networking<a hidden class="anchor" aria-hidden="true" href="#the-four-linux-primitives-behind-container-networking">#</a></h2>
<p>Docker and container runtimes, in general, did not invent container networking. They assemble a few Linux kernel features that have existed for years.</p>
<p>Container networking is built on four core primitives:</p>
<ul>
<li><strong>Network namespaces</strong></li>
<li><strong>Virtual Ethernet (veth) devices</strong></li>
<li><strong>Routing tables</strong></li>
<li><strong>NAT (iptables)</strong></li>
</ul>
<h3 id="network-namespaces-the-separate-network-worlds">Network Namespaces: The Separate Network Worlds<a hidden class="anchor" aria-hidden="true" href="#network-namespaces-the-separate-network-worlds">#</a></h3>
<p>A network namespace is a fully independent instance of the Linux networking stack.
When a process runs inside the namespace, it gets its own:</p>
<ul>
<li>Network interfaces</li>
<li>Routing table</li>
<li>ARP table</li>
<li>Firewall rules (iptables)</li>
<li>Loopback device</li>
</ul>
<p>It cannot see the host&rsquo;s networking interfaces, and the host cannot see its internal ones either (unless explicitly connected).
From a networking perspective, it&rsquo;s as if that process is running on a completely different machine.</p>
<blockquote>
<p>Container network isolation is simply a process placed inside its own network namespace.</p>
</blockquote>
<p>That&rsquo;s the foundation of container networking.</p>
<h3 id="virtual-ethernet-veth-pairs-the-wire-that-connects-the-worlds">Virtual Ethernet (veth) Pairs: The Wire that connects the Worlds<a hidden class="anchor" aria-hidden="true" href="#virtual-ethernet-veth-pairs-the-wire-that-connects-the-worlds">#</a></h3>
<p>Now we have two separate network worlds: the host and the namespace. They need a wire between them.
That wire is a <strong>veth pair.</strong></p>
<p>A veth pair is created as two connected virtual interfaces:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>veth-A &lt;<span style="color:#f92672">====</span> virtual cable <span style="color:#f92672">====</span>&gt; veth-B
</span></span></code></pre></div><p>Anything that enters one end comes out the other.</p>
<p>Typically:</p>
<ul>
<li>One end stays in the host</li>
<li>The other end is moved into the container&rsquo;s namespace</li>
</ul>
<p>This is how packets physically move between the container and the host network stack.</p>
<blockquote>
<p>A veth pair is just an Ethernet cable, except both ends live inside the kernel.</p>
</blockquote>
<h3 id="routing-how-packets-know-where-to-go">Routing: How Packets Know Where to Go<a hidden class="anchor" aria-hidden="true" href="#routing-how-packets-know-where-to-go">#</a></h3>
<p>Interfaces move packets, but routing tables decide where packets should be sent. Each namespace maintains its own routing table.</p>
<p>When a process sends traffic:</p>
<ol>
<li>Kernel checks the destination IP</li>
<li>Looks up the routing table</li>
<li>Chooses the correct interface</li>
</ol>
<p>Without a default route, a namespace can only talk to its own subnet. So if a container wants internet access, it needs a rule like:</p>
<blockquote>
<p>&ldquo;Anything not local -&gt; send to the host&rdquo;</p>
</blockquote>
<p>This rule makes the host act as a <strong>gateway.</strong></p>
<h3 id="nat-how-containers-reach-the-internet">NAT: How Containers Reach the Internet<a hidden class="anchor" aria-hidden="true" href="#nat-how-containers-reach-the-internet">#</a></h3>
<p>Containers usually use private IP addresses (like <code>10.x.x.x</code> or <code>172.x.x.x</code>). The internet doesn&rsquo;t know how to route traffic back to those.</p>
<p>So the host performs Network Address Translation (NAT)</p>
<p>When packets leave the host:</p>
<ul>
<li>The container&rsquo;s source IP is replaced with the host&rsquo;s IP</li>
<li>Return traffic comes back to the host</li>
<li>The kernel maps it back to the original container</li>
</ul>
<p>This is done using an iptables <strong>MASQUERADE</strong> rule</p>
<blockquote>
<p>Containers don&rsquo;t have public IPs. They borrow the host&rsquo;s identity when talking to the outside world.</p>
</blockquote>
<h2 id="putting-it-together">Putting It Together<a hidden class="anchor" aria-hidden="true" href="#putting-it-together">#</a></h2>
<p>At this point, container networking is no longer mysterious:</p>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Linux Primitive That Solves It</th>
</tr>
</thead>
<tbody>
<tr>
<td>Isolation</td>
<td>Network namespace</td>
</tr>
<tr>
<td>Connection to host</td>
<td>veth pair</td>
</tr>
<tr>
<td>Traffic direction</td>
<td>Routing table</td>
</tr>
<tr>
<td>Internet access</td>
<td>NAT (iptables)</td>
</tr>
</tbody>
</table>
<p>Docker is simply automating the creation and wiring of these pieces.</p>
<p>In the upcoming sections, we&rsquo;ll build this entire setup manually (the same way a container runtime does).</p>
<h2 id="building-container-networking-from-scratch">Building Container Networking From Scratch<a hidden class="anchor" aria-hidden="true" href="#building-container-networking-from-scratch">#</a></h2>
<p>Now we&rsquo;ll manually build the same network setup a container runtime creates automatically.</p>
<p>We will:</p>
<ol>
<li>Create a <strong>network namespace</strong></li>
<li>Connect it to the host using a <strong>veth pair</strong></li>
<li>Assign <strong>IP addresses</strong></li>
<li>Add <strong>routing</strong></li>
<li>Enable <strong>IP forwarding</strong></li>
<li>Add <strong>NAT</strong></li>
<li>Test <strong>connectivity</strong></li>
</ol>
<h3 id="1-create-a-network-namespace">1. Create a Network Namespace<a hidden class="anchor" aria-hidden="true" href="#1-create-a-network-namespace">#</a></h3>
<p>This namespace will act as our &ldquo;container&rdquo;.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip netns add myns
</span></span></code></pre></div><p>We can run commands inside it using:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip netns exec myns bash
</span></span></code></pre></div><p>At this point, the namespace exists. But it has no network connectivity except a downed loopback interface. Try listing the available links inside the namespace.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip netns exec myns ip link list
</span></span></code></pre></div><p>You&rsquo;ll see the loopback interface.</p>
<h3 id="2-create-a-veth-pair-virtual-cable">2. Create a veth Pair (Virtual Cable)<a hidden class="anchor" aria-hidden="true" href="#2-create-a-veth-pair-virtual-cable">#</a></h3>
<p>We&rsquo;ll now create a virtual Ethernet cable between the host and the namespace.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip link add veth-host type veth peer name veth-ns
</span></span></code></pre></div><p>This creates:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>veth-host &lt;<span style="color:#f92672">====</span>&gt; veth-ns
</span></span></code></pre></div><p>Move one end into the namespace:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip link set veth-ns netns myns
</span></span></code></pre></div><p>Now:</p>
<table>
<thead>
<tr>
<th>Side</th>
<th>Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host</td>
<td>veth-host</td>
</tr>
<tr>
<td>Namespace</td>
<td>veth-ns</td>
</tr>
</tbody>
</table>
<h3 id="3-assign-ip-addresses">3. Assign IP Addresses<a hidden class="anchor" aria-hidden="true" href="#3-assign-ip-addresses">#</a></h3>
<p>The two ends must be on the same subnet.</p>
<p><strong>Host side:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip addr add 10.10.0.1/24 dev veth-host 
</span></span><span style="display:flex;"><span>sudo ip link set veth-host up
</span></span></code></pre></div><p><strong>Namespace side:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip netns exec myns ip addr add 10.10.0.2/24 dev veth-ns 
</span></span><span style="display:flex;"><span>sudo ip netns exec myns ip link set veth-ns up 
</span></span><span style="display:flex;"><span>sudo ip netns exec myns ip link set lo up
</span></span></code></pre></div><p>Now the host and namespace can <strong>talk at Layer 3.</strong></p>
<p>Why bring up <code>lo</code>? Because every network stack expects a working loopback interface. This ensures localhost works correctly inside the namespace.</p>
<h3 id="4-add-a-default-route-inside-the-namespace">4. Add a Default Route Inside the Namespace<a hidden class="anchor" aria-hidden="true" href="#4-add-a-default-route-inside-the-namespace">#</a></h3>
<p>Right now the namespace only knows its local subnet.
We make the host act as a gateway:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip netns exec myns ip route add default via 10.10.0.1
</span></span></code></pre></div><p>Now any traffic destined outside <code>10.10.0.0/24</code> goes to the host. The namespace now has a <strong>default gateway.</strong></p>
<h3 id="5-enable-ip-forwarding-on-the-host">5. Enable IP Forwarding on the Host<a hidden class="anchor" aria-hidden="true" href="#5-enable-ip-forwarding-on-the-host">#</a></h3>
<p>Linux drops forwarded packets by default.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sysctl -w net.ipv4.ip_forward<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>The host can now behave like a <strong>router</strong>. This change is temporary and will reset after reboot.</p>
<h3 id="6-add-nat-masquerading">6. Add NAT (Masquerading)<a hidden class="anchor" aria-hidden="true" href="#6-add-nat-masquerading">#</a></h3>
<p>The namespace IP is private. We must rewrite packets leaving the host.</p>
<p>Replace <code>wlo1</code> with your internet-facing interface.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo iptables -t nat -A POSTROUTING -s 10.10.0.0/24 -o wlo1 -j MASQUERADE
</span></span></code></pre></div><p>This makes outbound traffic appear as if it originates from the host. This is the same mechanism home routers use to allow multiple devices to share one public IP.</p>
<h3 id="7-allow-forwarded-traffic">7. Allow Forwarded Traffic<a hidden class="anchor" aria-hidden="true" href="#7-allow-forwarded-traffic">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo iptables -A FORWARD -i veth-host -o wlo1 -j ACCEPT 
</span></span><span style="display:flex;"><span>sudo iptables -A FORWARD -o veth-host -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
</span></span></code></pre></div><p>These rules allow traffic to leave and return. The first rule allows outbound traffic from the namespace to the external interface. The second rule allows return traffic for established connections, so responses from the internet can flow back into the namespace.</p>
<h3 id="8-test-connectivity">8. Test Connectivity<a hidden class="anchor" aria-hidden="true" href="#8-test-connectivity">#</a></h3>
<p><strong>Namespace → Host</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip netns exec myns ping 10.10.0.1
</span></span></code></pre></div><p><strong>Namespace → Internet</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip netns exec myns ping 8.8.8.8
</span></span></code></pre></div><p>If this works, you have built <strong>container-style networking</strong> manually.</p>
<h2 id="what-we-just-built">What We Just Built<a hidden class="anchor" aria-hidden="true" href="#what-we-just-built">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>myns process    
</span></span><span style="display:flex;"><span>↓ 
</span></span><span style="display:flex;"><span>veth-ns    
</span></span><span style="display:flex;"><span>↓ 
</span></span><span style="display:flex;"><span>veth-host    
</span></span><span style="display:flex;"><span>↓ 
</span></span><span style="display:flex;"><span>Host routing table    
</span></span><span style="display:flex;"><span>↓ 
</span></span><span style="display:flex;"><span>iptables NAT <span style="color:#f92672">(</span>MASQUERADE<span style="color:#f92672">)</span>    
</span></span><span style="display:flex;"><span>↓ 
</span></span><span style="display:flex;"><span>wlo1    
</span></span><span style="display:flex;"><span>↓ 
</span></span><span style="display:flex;"><span>Router → Internet
</span></span></code></pre></div><p>At this point, the namespace can reach the host and the internet. That means we have successfully built container-style networking using nothing but Linux kernel primitives.</p>
<p>Let’s look at what actually happened.</p>
<ul>
<li>We created a separate network world using a <strong>network namespace</strong>.</li>
<li>We connected that world to the host using a <strong>veth pair</strong>.</li>
<li>We told the namespace where to send unknown traffic using a <strong>default route</strong>.</li>
<li>We allowed the host to forward packets by enabling <strong>IP forwarding</strong>.</li>
<li>We let the namespace talk to the internet by adding <strong>NAT (MASQUERADE)</strong> rules.</li>
</ul>
<p>That is the core of container networking.</p>
<p>When you run: <code>docker run nginx</code></p>
<p>Docker performs these same steps automatically. It creates a namespace for the container, wires it to the host network, adds routing rules, and inserts iptables rules so traffic can flow in and out. What feels like a high-level abstraction is just automation around standard Linux networking features.</p>
<p>What we built is the <strong>simplest container networking model:</strong> one isolated network stack using the host as its gateway.</p>
<blockquote>
<p>A container does not get special networking.<br>
It is simply a process inside a separate network namespace, connected to the host using a virtual Ethernet cable.<br>
The host acts as a router and performs NAT so the container can reach the internet.<br>
Everything else in container networking builds on this exact pattern.</p>
</blockquote>
<p>Real container platforms add another layer on top of this.</p>
<p>Instead of connecting each namespace directly to the host, they attach multiple namespaces to a <strong>Linux bridge</strong>, allowing containers to talk to each other as if they were on the same switch. That bridge is what Docker exposes as <code>docker0</code>.</p>
<p>We’ll build that in the next part.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://amalchandran.xyz/tags/linux/">Linux</a></li>
      <li><a href="https://amalchandran.xyz/tags/container/">Container</a></li>
      <li><a href="https://amalchandran.xyz/tags/networking/">Networking</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://amalchandran.xyz/">Amal Chandran M V</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
